from flask import Flask, jsonify, request
from pyshacl import validate
from flask_cors import CORS, cross_origin
import re

app = Flask(__name__)
CORS(app, origins="*")  # Enable CORS for all origins

@app.route('/api/validate', methods=['POST', 'OPTIONS'])
@cross_origin()
def validate_ttl():
    """
    Validates RDF data against SHACL shapes.

    This endpoint receives two files from the frontend: a data graph (RDF) and a shape graph (SHACL). 
    It validates the data graph against the shape graph and returns the validation results.

    Returns:
        JSON response with validation results, including:
        - conforms: Boolean indicating if the data graph conforms to the shape
        - parsed_data: List of structured violation messages (if any)
    """
    try:
        # Retrieve the files from the request
        data_graph = request.files['dg']
        shape_graph = request.files['sg']
        print(f"Validating {data_graph.filename} for shape {shape_graph.filename}")

        # Read the contents of the files
        dg = data_graph.read()
        sg = shape_graph.read()

        # Validate the RDF against SHACL shapes
        conforms, results_graph, results_text = validate(
            dg,
            shacl_graph=sg,
            inference='rdfs',
            abort_on_first=False,
            allow_infos=False,
            allow_warnings=False,
            meta_shacl=False,
            advanced=False,
            js=False,
            debug=False
        )

        # Parse results to extract structured violation data
        parsed_data = parse_results_text(results_text)

        # Prepare response data
        response_data = {
            'conforms': conforms,
            'parsed_data': parsed_data
        }

        return jsonify(response_data), 200

    except Exception as e:
        print(f"Error processing files: {e}")
        return jsonify({'status': 0}), 500  # Return error status


def parse_results_text(results_text):
    """
    Parses the validation results text to extract detailed violation information.

    Args:
        results_text (str): The results text generated by the SHACL validation.

    Returns:
        list: A list of structured violation information, each represented as a dictionary.
    """
    # Define regex patterns for extracting violation details
    constraint_pattern = re.compile(r'Constraint Violation in ([^\(]+) \((http[^\)]+)\):')
    severity_pattern = re.compile(r'Severity: ([^\n]+)')
    source_shape_pattern = re.compile(r'Source Shape: \[([^\]]+)\]')
    focus_node_pattern = re.compile(r'Focus Node: ([^\n]+)')
    result_path_pattern = re.compile(r'Result Path: ([^\n]+)')
    value_node_pattern = re.compile(r'Value Node: ([^\n]+)')  # Optional
    message_pattern = re.compile(r'Message: ([^\n]+)')

    # Split the results into individual constraint violations
    violations = results_text.split("Constraint Violation")
    
    # Initialize list to store structured violations
    structured_violations = []

    for violation in violations[1:]:  # Skip the first "Validation Report" header
        # Extract details using regex
        constraint_match = constraint_pattern.search(violation)
        severity_match = severity_pattern.search(violation)
        source_shape_match = source_shape_pattern.search(violation)
        focus_node_match = focus_node_pattern.search(violation)
        result_path_match = result_path_pattern.search(violation)
        value_node_match = value_node_pattern.search(violation)  # Optional
        message_match = message_pattern.search(violation)

        structured_violation = {
            "component": constraint_match.group(1).strip() if constraint_match else None,
            "component_url": constraint_match.group(2).strip() if constraint_match else None,
            "severity": severity_match.group(1).strip() if severity_match else None,
            "source_shape": source_shape_match.group(1).strip() if source_shape_match else None,
            "focus_node": focus_node_match.group(1).strip() if focus_node_match else None,
            "result_path": result_path_match.group(1).strip() if result_path_match else None,
            "value_node": value_node_match.group(1).strip() if value_node_match else None,  # Optional
            "message": message_match.group(1).strip() if message_match else None
        }

        structured_violations.append(structured_violation)

    return structured_violations

if __name__ == '__main__':
    app.run(host='localhost', port=5000, debug=True)  # Run the Flask application
